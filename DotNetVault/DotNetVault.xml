<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetVault</name>
    </assembly>
    <members>
        <member name="T:DotNetVault.Attributes.NoNonVsCaptureAttribute">
             <summary>
             This attribute is used to annotate the delegates used by locked mutable resource objects.
             <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/>  <seealso cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/>.
            
             This attribute is designed to prevent any non-vault-safe state in the protected resource from leaking outside the
             lock/vault or to prevent any such external state from becoming entangled with the protected resource.  Enforcement
             of the rules this attribute applies is accomplished via static analysis.  The following are the summary of the rules:
                 1. No non-vault-safe items may be referenced in the delegate (except for the protected resource), whether those non-vault-safe
                    objects are static fields or properties or are captured directly or indirectly (if "this" is not vault safe type, not even this
                    may be indirectly captured or referenced during the operation).  You may create a NEW protected resource inside the delegate, may
                    must assign it in the same statement to the protected resource. 
                 2. The protected resource may not be passed as a parameter to method outside the delegate
                 3. If the protected resource happens to be a vault-safe value (which should not normally be protected using the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/>
                    or custom-version like <seealso cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/>) it may not be passed by reference to any method inside the delegate.
             </summary>
        </member>
        <member name="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder">
             <summary>
             This is, with its companion <see cref="T:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault"/> shows how one might
             enhance the functionality provided by <see cref="T:DotNetVault.Vaults.MutableResourceVault`1"/> by providing a
             locked resource object that provides an interface more similar to the protected resource than
             the one provided by <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> as used by
             <see cref="T:DotNetVault.Vaults.MutableResourceVault`1"/>.  It wraps the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/>
             and exposes an interface similar to the one expected by users of the <see cref="T:System.Text.StringBuilder"/> type.
            
             All such custom locked resources:
              1- should be ref structs (to prevent them from being stored on the heap either from boxing or as field
                 of a reference type and to prevent them from being stored in static memory),
              2- should have a public <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.Dispose"/> method with the same signature as this type which
                 disposes the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> it wraps, 
              3- should expose an interface similar to that of the protected resource, except all parameters
                 passed to the methods and retrieved from the methods MUST be Vault-Safe. 
              4- should have a private constructor that accepts the appropriate <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> to wrap,
              5- should be in the same assembly as your custom <see cref="T:DotNetVault.Interfaces.IVault"/> object,
              6- should expose an internal factory method, used only by your <see cref="T:DotNetVault.Interfaces.IVault"/> object's public
                 Lock() and SpinLock() overloads (all of which should have return type of this type,
                 annotated with the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>. 
             </summary>
             <remarks>For performance reasons, you may also want to expose the wrapped <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/>'s
             ExecuteQuery, PerformAction and ExecuteMixedOperation methods-- if you will be calling this api repeatedly (say in a loop), you may wish
             to avoid the overhead of a delegate invocation per call.
             </remarks>
             <remarks>
             For some types, you may need to substitute VaultSafe alternatives (such as <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> for <see cref="T:System.Collections.Generic.List`1"/>)
             or you may not be able to provide the entire API.
             </remarks>
        </member>
        <member name="P:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.Length">
            <summary>
            <seealso cref="P:System.Text.StringBuilder.Length"/>
            </summary>
        </member>
        <member name="P:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.MaxCapacity">
            <summary>
            <see cref="P:System.Text.StringBuilder.MaxCapacity"/>
            </summary>
        </member>
        <member name="P:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.Capacity">
            <summary>
            <seealso cref="P:System.Text.StringBuilder.Capacity"/>
            </summary>
        </member>
        <member name="P:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.Item(System.Int32)">
            <summary>
            <seealso cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="idx">index of the character you wish to access</param>
            <returns>the character stored at the specified index</returns>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.#ctor(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})">
            <summary>
            Private CTOR
            </summary>
            <param name="wrappedLockedResource">The resource from <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> that this object will be wrapping
            and assuming disposal obligations</param>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.Contains(System.Char)">
            <summary>
            Query whether the stringbuilder contains the specified resource
            </summary>
            <param name="c">the character whose presence vel-non in the <see cref="T:System.Text.StringBuilder"/>
            you wish to determine</param>
            <returns>true if found, false otherwise</returns>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.Dispose">
            <summary>
            Release the lock on the <see cref="T:System.Text.StringBuilder"/>, returning it to the vault
            for use on other threads
            </summary>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.Append(System.String)">
            <summary>
            Append the specified text to the end of the <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="appendMe">the text to append</param>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.AppendLine(System.String)">
            <summary>
            Append the specified text followed by a "newline" character to the <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="appendMe">the string to append</param>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.Clear">
            <summary>
            Empties the <see cref="T:System.Text.StringBuilder"/>
            </summary>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.ToString">
            <summary>
            Retrieve the string representation of the protected object in its current state
            </summary>
            <returns>string rep of protected object</returns>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.IndexOf(System.Char)">
            <summary>
            Find the first index of the specified character.
            </summary>
            <param name="c">the character whose index you seek</param>
            <returns>the first index whereat the specified character is found, if found; -1 otherwise</returns>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CopyTo(System.Collections.Immutable.ImmutableArray{System.Char},System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies the characters stored in the string builder to a new <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> along
            with the characters in the specified <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> starting at <paramref name="toMe"/>'s
            <paramref name="targetStartIdx"/> index and the <see cref="T:System.Text.StringBuilder"/>'s <paramref name="sbStartIdx"/> index
            and continuing for the next <paramref name="numChars"/> characters in the <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <returns>A new mutable array with values as if the copy had been written to <paramref name="toMe"/> in the manner specified.</returns>
            <remarks>Obviously, does not actually change the contents of <paramref name="toMe"/></remarks>
        </member>
        <member name="T:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault">
            <summary>
            Inherit this directly from Vault base class <see cref="T:DotNetVault.Vaults.Vault`1"/>
            This is an example of how to make a custom vault with a custom locked resource type:
            the primary advantage to using this rather than a plain <see cref="T:DotNetVault.Vaults.MutableResourceVault`1"/> is because
            you can provide an API similar to the protected resource's API and not have to always rely on sometimes awkward
            delegates.  Consult this and <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> (it's custom locked resource type) to see how this is
            done.  <see cref="T:System.Text.StringBuilder"/> was chosen because it is paradigmatic of non-vault-safe types:
            reference types that have mutable state and has a well-known public interface which may be preferable to use
            of delegates and closures for query and mutation actions performed on it while protected.
            </summary>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.#ctor(System.TimeSpan,System.Func{System.Text.StringBuilder})">
            <summary>
            CTOR.  Creates a vault.
            </summary>
            <param name="defaultTimeout">the default amount of time that should be waited when calling parameterless
            <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock"/> and <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> methods</param>
            <param name="stringBuilderGen">A function that creates a <see cref="T:System.Text.StringBuilder"/> that will be protected
            by the vault.  This delegate should create a NEW string builder and simply return it ... not storing
            any references to it anywhere, otherwise the vault cannot effectively guard it.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stringBuilderGen"/> was null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="defaultTimeout"/> was not positive.</exception>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.#ctor(System.String,System.TimeSpan)">
            <summary>
            CTOR.  Creates a vault with a string builder that contains the contents of the string specified.
            </summary>
            <param name="fromMe">starting contents of protected <see cref="T:System.Text.StringBuilder"/></param>
            <param name="defaultTimeOut">the default amount of time that should be waited when calling parameterless
            <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock"/> and <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> methods</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="fromMe"/> was null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="defaultTimeOut"/> was not positive.</exception>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.#ctor(System.Collections.Generic.IEnumerable{System.Char},System.TimeSpan)">
            <summary>
            CTOR.  Creates a vault from the supplied collection of characters.
            </summary>
            <param name="fromUs">a collection of characters which should be copied into the new vault's protected resource,
            as its starting value</param>
            <param name="defaultTimeout">the default amount of time that should be waited when calling parameterless
            <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock"/> and <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> methods</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="fromUs"/> was null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="defaultTimeout"/> was null</exception>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.#ctor(System.TimeSpan)">
            <summary>
            CTOR Creates a vault.
            </summary>
            <param name="defaultTimeout">the default amount of time that should be waited when calling parameterless
            <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock"/> and <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> methods</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>Protected <see cref="T:System.Text.StringBuilder"/> will be default constructed</remarks>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock(System.TimeSpan)">
            <summary>
            All public methods that return a CustomLockedResource (here a LockedStringBuilder) should be have their return values
            annotated with the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> attribute.  The methods should call the protected method
            <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/>.  This method is protected (not for public consumption
            except as herein described) because it does not require the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which requires the IMMEDIATE callee
            to dispose of it.  You should guard your call to <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/> with a try catch
            and be sure to dispose it on any path that does not lead to it successfully calling <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/>,
            passing the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> to that <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/> method
            and returning the result to the user.  You should NOT dispose the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> in the success path.
            The <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> object returned will dispose it when it is disposed and the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> guarantees that the immediate
            caller MUST guard it with a using statement, guaranteeing its disposal before it goes out of scope.
            </summary>
            <param name="timeout">How long you want to wait to acquire the resource before throwing a <see cref="T:System.TimeoutException"/></param>
            <returns>A custom LockedResource object (in this case) <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> which is guarded by the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which
            requires the caller to guard it with a using statement on pain of compiler error./</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Timespan must be greater than <see cref="F:System.TimeSpan.Zero"/></exception>
            <exception cref="T:System.InvalidOperationException">The vault is disposed or being disposed.</exception>
            <exception cref="T:System.TimeoutException">The resource was not acquired within the time specified.  Is it already acquired on the same thread?
            If you are obtaining locks on multiple vaults, do you always do it in the same order?  Is resource contention higher than you anticipated?
            </exception>
            <exception cref="T:System.OperationCanceledException">the operation was canceled</exception>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock">
            <summary>
            All public methods that return a CustomLockedResource (here a LockedStringBuilder) should be have their return values
            annotated with the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> attribute.  The methods should call the protected method
            <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/>.  This method is protected (not for public consumption
            except as herein described) because it does not require the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which requires the IMMEDIATE callee
            to dispose of it.  You should guard your call to <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/> with a try catch
            and be sure to dispose it on any path that does not lead to it successfully calling <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/>,
            passing the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> to that <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/> method
            and returning the result to the user.  You should NOT dispose the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> in the success path.
            The <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> object returned will dispose it when it is disposed and the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> guarantees that the immediate
            caller MUST guard it with a using statement, guaranteeing its disposal before it goes out of scope.
            </summary>
            <returns>A custom LockedResource object (in this case) <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> which is guarded by the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which
            requires the caller to guard it with a using statement on pain of compiler error./</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Timespan must be greater than <see cref="F:System.TimeSpan.Zero"/></exception>
            <exception cref="T:System.InvalidOperationException">The vault is disposed or being disposed.</exception>
            <exception cref="T:System.TimeoutException">The resource was not acquired within the time specified.  Is it already acquired on the same thread?
            If you are obtaining locks on multiple vaults, do you always do it in the same order?  Is resource contention higher than you anticipated?
            </exception>
            <exception cref="T:System.OperationCanceledException">the operation was canceled</exception>
            <remarks>Waits for the time specified by <see cref="P:DotNetVault.Vaults.Vault`1.DefaultTimeout"/></remarks>
            <remarks>NOTE this method and its <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock(System.TimeSpan)"/> overload sleep for brief periods
            in between attempts to obtain the lock.  If you want a busy wait, call <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock(System.TimeSpan)"/> or <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> </remarks>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock(System.Threading.CancellationToken)">
            <summary>
            All public methods that return a CustomLockedResource (here a LockedStringBuilder) should be have their return values
            annotated with the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> attribute.  The methods should call the protected method
            <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/>.  This method is protected (not for public consumption
            except as herein described) because it does not require the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which requires the IMMEDIATE callee
            to dispose of it.  You should guard your call to <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/> with a try catch
            and be sure to dispose it on any path that does not lead to it successfully calling <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/>,
            passing the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> to that <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/> method
            and returning the result to the user.  You should NOT dispose the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> in the success path.
            The <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> object returned will dispose it when it is disposed and the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> guarantees that the immediate
            caller MUST guard it with a using statement, guaranteeing its disposal before it goes out of scope.
            </summary>
            <param name="token">a cancellation token whereby the attempt to obtain the resource may be cancelled.</param>
            <returns>A custom LockedResource object (in this case) <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> which is guarded by the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which
            requires the caller to guard it with a using statement on pain of compiler error./</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Timespan must be greater than <see cref="F:System.TimeSpan.Zero"/></exception>
            <exception cref="T:System.InvalidOperationException">The vault is disposed or being disposed.</exception>
            <exception cref="T:System.TimeoutException">The resource was not acquired within the time specified.  Is it already acquired on the same thread?
            If you are obtaining locks on multiple vaults, do you always do it in the same order?  Is resource contention higher than you anticipated?
            </exception>
            <exception cref="T:System.OperationCanceledException">the operation was canceled</exception>
            <remarks>Busy-waits until the resource is obtained or the <paramref name="token"/>'s <see cref="T:System.Threading.CancellationTokenSource"/>
            requests the operation be cancelled.</remarks>
            <remarks>NOTE this method and its <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> overload busy-wait, keeping the thread active throughout the wait.
            Although it MAY result in quicker performance, it will be at the cost of CPU time and power expenditure -- also, if this thread stays active too long in
            a busy-wait, the operating System may pre-empt the thread, causing a longer wait than if you had yielded control to the OS periodically on failure.
            If you want to periodically sleep, call <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock(System.TimeSpan)"/> or <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock"/> instead</remarks>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock(System.Threading.CancellationToken,System.TimeSpan)">
            <summary>
            All public methods that return a CustomLockedResource (here a LockedStringBuilder) should be have their return values
            annotated with the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> attribute.  The methods should call the protected method
            <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/>.  This method is protected (not for public consumption
            except as herein described) because it does not require the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which requires the IMMEDIATE callee
            to dispose of it.  You should guard your call to <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/> with a try catch
            and be sure to dispose it on any path that does not lead to it successfully calling <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/>,
            passing the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> to that <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/> method
            and returning the result to the user.  You should NOT dispose the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> in the success path.
            The <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> object returned will dispose it when it is disposed and the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> guarantees that the immediate
            caller MUST guard it with a using statement, guaranteeing its disposal before it goes out of scope.
            </summary>
            <param name="token">a cancellation token whereby cancellation of the attempt to obtain the lock can be cancelled.</param>
            <param name="timeout">the maximum amount of time to wait to obtain the resource before throwing <see cref="T:System.TimeoutException"/></param>
            <returns>A custom LockedResource object (in this case) <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> which is guarded by the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which
            requires the caller to guard it with a using statement on pain of compiler error./</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Timespan must be greater than <see cref="F:System.TimeSpan.Zero"/></exception>
            <exception cref="T:System.InvalidOperationException">The vault is disposed or being disposed.</exception>
            <exception cref="T:System.TimeoutException">The resource was not acquired within the time specified.  Is it already acquired on the same thread?
            If you are obtaining locks on multiple vaults, do you always do it in the same order?  Is resource contention higher than you anticipated?
            </exception>
            <exception cref="T:System.OperationCanceledException">the operation was canceled</exception>
            <remarks>Waits until the resource is obtained, the <paramref name="token"/> <see cref="T:System.Threading.CancellationTokenSource"/>
            requests the operation be cancelled or the time specified by <paramref name="timeout"/> parameter is exceeded.</remarks>
            <remarks>NOTE this method and its <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> overload busy-wait, keeping the thread active throughout the wait.
            Although it MAY result in quicker performance, it will be at the cost of CPU time and power expenditure -- also, if this thread stays active too long in
            a busy-wait, the operating System may pre-empt the thread, causing a longer wait than if you had yielded control to the OS periodically on failure.
            If you want to periodically sleep, call <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock(System.TimeSpan)"/> or <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock"/> instead</remarks>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock(System.TimeSpan)">
            <summary>
            All public methods that return a CustomLockedResource (here a LockedStringBuilder) should be have their return values
            annotated with the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> attribute.  The methods should call the protected method
            <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/>.  This method is protected (not for public consumption
            except as herein described) because it does not require the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which requires the IMMEDIATE callee
            to dispose of it.  You should guard your call to <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/> with a try catch
            and be sure to dispose it on any path that does not lead to it successfully calling <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/>,
            passing the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> to that <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/> method
            and returning the result to the user.  You should NOT dispose the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> in the success path.
            The <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> object returned will dispose it when it is disposed and the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> guarantees that the immediate
            caller MUST guard it with a using statement, guaranteeing its disposal before it goes out of scope.
            </summary>
            <param name="timeout">How long you wish to wait to obtain the lock before throwing an <see cref="T:System.TimeoutException"/>.</param>
            <returns>A custom LockedResource object (in this case) <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> which is guarded by the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which
            requires the caller to guard it with a using statement on pain of compiler error./</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Timespan must be greater than <see cref="F:System.TimeSpan.Zero"/></exception>
            <exception cref="T:System.InvalidOperationException">The vault is disposed or being disposed.</exception>
            <exception cref="T:System.TimeoutException">The resource was not acquired within the time specified.  Is it already acquired on the same thread?
            If you are obtaining locks on multiple vaults, do you always do it in the same order?  Is resource contention higher than you anticipated?
            </exception>
            <exception cref="T:System.OperationCanceledException">the operation was canceled</exception>
            <remarks>Waits for the time specified by <see cref="P:DotNetVault.Vaults.Vault`1.DefaultTimeout"/></remarks>
            <remarks>NOTE this method and its <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> overload busy-wait, keeping the thread active throughout the wait.
            Although it MAY result in quicker performance, it will be at the cost of CPU time and power expenditure -- also, if this thread stays active too long in
            a busy-wait, the operating System may pre-empt the thread, causing a longer wait than if you had yielded control to the OS periodically on failure.
            If you want to periodically sleep, call <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock(System.TimeSpan)"/> or <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock"/> instead</remarks>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock">
            <summary>
            All public methods that return a CustomLockedResource (here a LockedStringBuilder) should be have their return values
            annotated with the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> attribute.  The methods should call the protected method
            <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/>.  This method is protected (not for public consumption
            except as herein described) because it does not require the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which requires the IMMEDIATE callee
            to dispose of it.  You should guard your call to <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/> with a try catch
            and be sure to dispose it on any path that does not lead to it successfully calling <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/>,
            passing the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> to that <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/> method
            and returning the result to the user.  You should NOT dispose the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> in the success path.
            The <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> object returned will dispose it when it is disposed and the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> guarantees that the immediate
            caller MUST guard it with a using statement, guaranteeing its disposal before it goes out of scope.
            </summary>
            <returns>A custom LockedResource object (in this case) <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> which is guarded by the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which
            requires the caller to guard it with a using statement on pain of compiler error./</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Timespan must be greater than <see cref="F:System.TimeSpan.Zero"/></exception>
            <exception cref="T:System.InvalidOperationException">The vault is disposed or being disposed.</exception>
            <exception cref="T:System.TimeoutException">The resource was not acquired within the time specified.  Is it already acquired on the same thread?
            If you are obtaining locks on multiple vaults, do you always do it in the same order?  Is resource contention higher than you anticipated?
            </exception>
            <exception cref="T:System.OperationCanceledException">the operation was canceled</exception>
            <remarks>Waits for the time specified by <see cref="P:DotNetVault.Vaults.Vault`1.DefaultTimeout"/></remarks>
            <remarks>NOTE this method and its <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> overload busy-wait, keeping the thread active throughout the wait.
            Although it MAY result in quicker performance, it will be at the cost of CPU time and power expenditure -- also, if this thread stays active too long in
            a busy-wait, the operating System may pre-empt the thread, causing a longer wait than if you had yielded control to the OS periodically on failure.
            If you want to periodically sleep, call <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock(System.TimeSpan)"/> or <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock"/> instead</remarks>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock(System.Threading.CancellationToken)">
            <summary>
            All public methods that return a CustomLockedResource (here a LockedStringBuilder) should be have their return values
            annotated with the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> attribute.  The methods should call the protected method
            <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/>.  This method is protected (not for public consumption
            except as herein described) because it does not require the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which requires the IMMEDIATE callee
            to dispose of it.  You should guard your call to <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/> with a try catch
            and be sure to dispose it on any path that does not lead to it successfully calling <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/>,
            passing the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> to that <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/> method
            and returning the result to the user.  You should NOT dispose the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> in the success path.
            The <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> object returned will dispose it when it is disposed and the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> guarantees that the immediate
            caller MUST guard it with a using statement, guaranteeing its disposal before it goes out of scope.
            </summary>
            <returns>A custom LockedResource object (in this case) <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> which is guarded by the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which
            requires the caller to guard it with a using statement on pain of compiler error./</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Timespan must be greater than <see cref="F:System.TimeSpan.Zero"/></exception>
            <exception cref="T:System.InvalidOperationException">The vault is disposed or being disposed.</exception>
            <exception cref="T:System.TimeoutException">The resource was not acquired within the time specified.  Is it already acquired on the same thread?
            If you are obtaining locks on multiple vaults, do you always do it in the same order?  Is resource contention higher than you anticipated?
            </exception>
            <exception cref="T:System.OperationCanceledException">the operation was canceled</exception>
            <remarks>Busy-waits until the resource is obtained or the <paramref name="token"/>'s <see cref="T:System.Threading.CancellationTokenSource"/>
            requests the operation be cancelled.</remarks>
            <remarks>NOTE this method and its <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> overload busy-wait, keeping the thread active throughout the wait.
            Although it MAY result in quicker performance, it will be at the cost of CPU time and power expenditure -- also, if this thread stays active too long in
            a busy-wait, the operating System may pre-empt the thread, causing a longer wait than if you had yielded control to the OS periodically on failure.
            If you want to periodically sleep, call <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock(System.TimeSpan)"/> or <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock"/> instead</remarks>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock(System.Threading.CancellationToken,System.TimeSpan)">
            <summary>
            All public methods that return a CustomLockedResource (here a LockedStringBuilder) should be have their return values
            annotated with the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> attribute.  The methods should call the protected method
            <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/>.  This method is protected (not for public consumption
            except as herein described) because it does not require the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which requires the IMMEDIATE callee
            to dispose of it.  You should guard your call to <see cref="M:DotNetVault.Vaults.CustomizableMutableResourceVault`1.GetLockedResourceBase(System.Nullable{System.TimeSpan},System.Threading.CancellationToken,System.Boolean)"/> with a try catch
            and be sure to dispose it on any path that does not lead to it successfully calling <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/>,
            passing the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> to that <see cref="M:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder.CreateLockedResource(DotNetVault.LockedResources.LockedVaultMutableResource{DotNetVault.Vaults.MutableResourceVault{System.Text.StringBuilder},System.Text.StringBuilder})"/> method
            and returning the result to the user.  You should NOT dispose the <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> in the success path.
            The <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> object returned will dispose it when it is disposed and the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/> guarantees that the immediate
            caller MUST guard it with a using statement, guaranteeing its disposal before it goes out of scope.
            </summary>
            <param name="token">a cancellation token whereby cancellation of the attempt to obtain the lock can be cancelled.</param>
            <param name="timeout">the maximum amount of time to wait to obtain the resource before throwing <see cref="T:System.TimeoutException"/></param>
            <returns>A custom LockedResource object (in this case) <see cref="T:DotNetVault.CustomVaultExamples.CustomLockedResources.LockedStringBuilder"/> which is guarded by the <see cref="T:DotNetVault.Attributes.UsingMandatoryAttribute"/>, which
            requires the caller to guard it with a using statement on pain of compiler error./</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Timespan must be greater than <see cref="F:System.TimeSpan.Zero"/></exception>
            <exception cref="T:System.InvalidOperationException">The vault is disposed or being disposed.</exception>
            <exception cref="T:System.TimeoutException">The resource was not acquired within the time specified.  Is it already acquired on the same thread?
            If you are obtaining locks on multiple vaults, do you always do it in the same order?  Is resource contention higher than you anticipated?
            </exception>
            <exception cref="T:System.OperationCanceledException">the operation was canceled</exception>
            <remarks>Busy-waits until the resource is obtained, the <paramref name="token"/>'s <see cref="T:System.Threading.CancellationTokenSource"/>
            requests the operation be cancelled or the time specified by <paramref name="timeout"/> parameter is exceeded.</remarks>
            <remarks>NOTE this method and its <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.SpinLock"/> overload busy-wait, keeping the thread active throughout the wait.
            Although it MAY result in quicker performance, it will be at the cost of CPU time and power expenditure -- also, if this thread stays active too long in
            a busy-wait, the operating System may pre-empt the thread, causing a longer wait than if you had yielded control to the OS periodically on failure.
            If you want to periodically sleep, call <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock(System.TimeSpan)"/> or <seealso cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.Lock"/> instead</remarks>
        </member>
        <member name="T:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.StringBuilderVaultImpl">
            <summary>
            Make a nested class (private or protected) that inherits from the abstract class <see cref="T:DotNetVault.Vaults.CustomizableMutableResourceVault`1"/>
            Calls in <see cref="T:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault"/> (or your custom vault) are delegated to this implementation class.
            </summary>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.StringBuilderVaultImpl.CreateStringBuilderVaultImpl(System.TimeSpan,System.Func{System.Text.StringBuilder})">
            <summary>
            Add the following factory method to the nested class
            </summary>
            <param name="defaultTimeOut">the default time-out</param>
            <param name="resourceGen">a function to generate the initial value of the protected resource</param>
            <returns>An implementation of <see cref="T:DotNetVault.Vaults.CustomizableMutableResourceVault`1"/> that your custom class
            (here <see cref="T:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault"/>) will delegate to.</returns>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.StringBuilderVaultImpl.#ctor(System.TimeSpan)">
            <summary>
            Create whatever ctors necessary to call base impl class.
            </summary>
            <param name="defaultTimeout">the timeout</param>
        </member>
        <member name="T:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.StringBuilderVaultImpl.StringBuilderVaultImplFactory">
            <summary>
            Derive from the factory if needed to be used in static factory method shown <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.StringBuilderVaultImpl.CreateStringBuilderVaultImpl(System.TimeSpan,System.Func{System.Text.StringBuilder})"/>
            </summary>
        </member>
        <member name="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.StringBuilderVaultImpl.StringBuilderVaultImplFactory.CreateSbImplFactory">
            <summary>
            don't forget to make this method name here different than <see cref="!:MutableResourceVaultFactory&lt;TDerivedMutableResourceVault&gt;.CreateFactory()"/>
            especially if there are any differences
            </summary>
            <returns>a factory object to be used in the static factory method <see cref="M:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault.StringBuilderVaultImpl.CreateStringBuilderVaultImpl(System.TimeSpan,System.Func{System.Text.StringBuilder})"/> above.
            </returns>
        </member>
        <member name="M:DotNetVault.Interfaces.IDelegateNoNonVsCaptureAnalyzer.ScanForNoNonVsCaptureAttribAndRetrieveAnalyteData(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)">
            <summary>
            Scan the analysis context to 
                1-  determine whether the operation involves the creation of a delegate
                    annotated with the <see cref="T:DotNetVault.Attributes.NoNonVsCaptureAttribute"/> attribute and, if so
                2-  gather the information needed to perform compliance analysis
            </summary>
            <param name="con">the operation analysis context.  for efficiency purposes, it is best to only supply a context
             whose <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.Operation"/> property returns an object of type <see cref="T:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation"/>:
             if not, no further analysis is needed or required.  </param>
            <returns>A value tuple whose first value is true if further analysis is required or false otherwise.  If true, the other
            values in the tuple are guaranteed not to be null.  If false, the other values are undefined and may well be null.</returns>
            <exception cref="T:System.OperationCanceledException"></exception>
        </member>
        <member name="M:DotNetVault.Interfaces.IDelegateNoNonVsCaptureAnalyzer.AnalyzeOperationForCompliance(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)">
            <summary>
            Scan the specified delegate creation operation <paramref name="delCrOp"/> to ensure it complies with rules associated with
            delegates annotated with the <seealso cref="T:DotNetVault.Attributes.NoNonVsCaptureAttribute"/> attribute.  All the parameters passed should be retrieval
            results for a call to the <see cref="M:DotNetVault.Interfaces.IDelegateNoNonVsCaptureAnalyzer.ScanForNoNonVsCaptureAttribAndRetrieveAnalyteData(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)"/> whose IdentifiedAttribute value is true.
            </summary>
            <param name="targetOp">The target operation as retrieved by the <see cref="M:DotNetVault.Interfaces.IDelegateNoNonVsCaptureAnalyzer.ScanForNoNonVsCaptureAttribAndRetrieveAnalyteData(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)"/> method.</param>
            <param name="delCrOp">The delegate creation operation as retrieved by the <see cref="M:DotNetVault.Interfaces.IDelegateNoNonVsCaptureAnalyzer.ScanForNoNonVsCaptureAttribAndRetrieveAnalyteData(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)"/> method.</param>
            <param name="assignee">The named type symbol as retrieved by the <see cref="M:DotNetVault.Interfaces.IDelegateNoNonVsCaptureAnalyzer.ScanForNoNonVsCaptureAttribAndRetrieveAnalyteData(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)"/> method</param>
            <param name="con">the operation analysis context</param>
            <returns>A value tuple.  The first value will be: true if operation is known to be compliant, false if operation is known to be non-compliant and
            null if its compliance vel-non is unknown.  If false, NonVsCaptures will contain all offending type symbols that are not vault safe and NonVsCapture text
            (the arrays are to be considered parallel) will contain brief text explaining the reason for that symbol's non compliance.</returns>
            <exception cref="T:System.ArgumentNullException">one of the parameters was null.</exception>
            <exception cref="T:System.OperationCanceledException">analysis was cancelled</exception>
        </member>
        <member name="M:DotNetVault.Interfaces.IImmutableGenericTypeLookup.FindMatch(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Check to see whether a (potentially closed) named type symbol is one of the immutable generic types
            </summary>
            <param name="typeSymbol">the type symbol to check</param>
            <returns>A tuple whose IsDesignated property is true for a match, false for no match.  If a match, the MatchingOpenTypeSymbol
            will be the type symbol representing the unbound generic type that is a match.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="typeSymbol"/> was null</exception>
        </member>
        <member name="M:DotNetVault.Interfaces.IImmutableGenericTypeLookup.FindMatch(System.String)">
            <summary>
            Check whether the metadataName refers to a (potentially closed) named type symbol that is one of the immutable generic types
            </summary>
            <param name="typeMetaDataName">The metadata name of type type to find</param>
            <returns>A tuple whose IsDesignated property is true for a match, false for no match.  If a match, the MatchingOpenTypeSymbol
            will be the type symbol representing the unbound generic type that is a match.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="typeMetaDataName"/> was null</exception>
        </member>
        <member name="T:DotNetVault.Interfaces.IVault">
            <summary>
            An interface specifying the properties and operations common to all vaults
            </summary>
        </member>
        <member name="P:DotNetVault.Interfaces.IVault.DisposeInProgress">
            <summary>
            True if a dispose is currently in progress but not yet complete
            </summary>
        </member>
        <member name="P:DotNetVault.Interfaces.IVault.IsDisposed">
            <summary>
            True if the vault has been disposed.
            </summary>
        </member>
        <member name="M:DotNetVault.Interfaces.IVault.TryDispose(System.TimeSpan)">
            <summary>
            Since inability to dispose lock may cause <see cref="M:System.IDisposable.Dispose"/>
            to throw an exception (generally something to avoid), it is best to attempt
            disposal with this timed-out dispose method to detect problems without
            problematic exception being thrown on Dispose.
            </summary>
            <param name="timeout">How long to wait before stopping attempt to obtain resource for
            disposal purposes.</param>
            <returns>true for success, false for failure</returns>
        </member>
        <member name="P:DotNetVault.Interfaces.IVault.DisposeTimeout">
            <summary>
            How long should we wait during the dispose method to attempt to acquire resource before throwing
            a <see cref="T:System.TimeoutException"/>.  Similar to <see cref="P:DotNetVault.Interfaces.IVault.DefaultTimeout"/> but applies during <see cref="M:System.IDisposable.Dispose"/>
            method call only.
            </summary>
        </member>
        <member name="P:DotNetVault.Interfaces.IVault.SleepInterval">
            <summary>
            How long should the sleep period be when trying to obtain lock.  IDeally as small as possible.
            100 milliseconds at absolute most. 
            </summary>
        </member>
        <member name="P:DotNetVault.Interfaces.IVault.DefaultTimeout">
            <summary>
            When not supplied with a timeout, how long Lock() and SpinLock()
            methods should wait before throwing a <see cref="T:System.TimeoutException"/>
            </summary>
        </member>
        <member name="T:DotNetVault.LockedResources.VaultQuery`2">
            <summary>
            A delegate used to perform a query on the current status of an object locked by a
            <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> object or by a custom version
            thereof <seealso cref="T:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault"/>.
            </summary>
            <typeparam name="TResource">The type of protected resource</typeparam>
            <typeparam name="TResult">The return type of the query (must be vault-safe)</typeparam>
            <param name="res">the protected resource </param>
            <returns>The result</returns>
            <remarks>See <see cref="T:DotNetVault.Attributes.NoNonVsCaptureAttribute"/> and the limitations it imposes on the semantics of
            delegates so-annotated.</remarks>
        </member>
        <member name="T:DotNetVault.LockedResources.VaultQuery`3">
            <summary>
            A delegate used to perform a query on the current status of an object locked by a
            <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/> object or by a custom version
            thereof <seealso cref="T:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault"/>.
            </summary>
            <typeparam name="TResource">The type of protected resource</typeparam>
            <typeparam name="TResult">The return type of the query (must be vault-safe) </typeparam>
            <typeparam name="TAncillary">An ancillary parameter, which must be a vault-safe value passed by
            constant reference, used in the delegate.</typeparam>
            <param name="res">the protected resource </param>
            <param name="ancillary">an ancillary vault-safe value passed by readonly-reference</param>
            <returns>The result</returns>
            <remarks>See <see cref="T:DotNetVault.Attributes.NoNonVsCaptureAttribute"/> and the limitations it imposes on the semantics of
            delegates so-annotated.</remarks>
        </member>
        <member name="T:DotNetVault.LockedResources.VaultAction`1">
            <summary>
            Execute a potentially mutating action on the vault
            </summary>
            <typeparam name="TResource">the type of protected resource you wish to mutate</typeparam>
            <param name="res">the protected resource on which you wish to perform a mutation.</param>
        </member>
        <member name="T:DotNetVault.LockedResources.VaultAction`2">
            <summary>
            Execute a potentially mutating action on the vault
            </summary>
            <typeparam name="TResource">the type of protected resource you wish to mutate</typeparam>
            <typeparam name="TAncillary">an ancillary type used in the delegate.  must be vault safe, must be passed
            by readonly-reference.</typeparam>
            <param name="res">the protected resource on which you wish to perform a mutation.</param>
            <remarks>See <see cref="T:DotNetVault.Attributes.NoNonVsCaptureAttribute"/> and the limitations it imposes on the semantics of
            delegates so-annotated.</remarks>
        </member>
        <member name="T:DotNetVault.LockedResources.VaultMixedOperation`2">
            <summary>
            Execute a mixed query: a value is desired and returned, but mutation may also happen to protected resource during the
            operation
            </summary>
            <typeparam name="TResource">The protected resource type</typeparam>
            <typeparam name="TResult">The result type</typeparam>
            <param name="res">the protected resource</param>
            <returns>the result</returns>
            <remarks>See <see cref="T:DotNetVault.Attributes.NoNonVsCaptureAttribute"/> and the limitations it imposes on the semantics of
            delegates so-annotated.</remarks>
        </member>
        <member name="T:DotNetVault.LockedResources.VaultMixedOperation`3">
            <summary>
            Execute a mixed query: a value is desired and returned, but mutation may also happen to protected resource during the
            operation
            </summary>
            <typeparam name="TResource">The protected resource type</typeparam>
            <typeparam name="TAncillary">an ancillary type to be used in the delegate.  must be vault-safe, must be passed by
            readonly-reference.</typeparam>
            <typeparam name="TResult">The result type</typeparam>
            <param name="res">the protected resource</param>
            <returns>the result</returns>
            <remarks>See <see cref="T:DotNetVault.Attributes.NoNonVsCaptureAttribute"/> and the limitations it imposes on the semantics of
            delegates so-annotated.</remarks>
        </member>
        <member name="T:DotNetVault.LockedResources.LockedVaultMutableResource`2">
            <summary>
            Represents a lock on a resource acquired from a mutable resource vault.  Unlike the <see cref="T:DotNetVault.Vaults.BasicVault`1"/>
            and it's <see cref="T:DotNetVault.LockedResources.LockedVaultObject`2"/>, this lock is taken
            on a NON-VAULT-SAFE-TYPE -- such as one guarded by a <see cref="T:DotNetVault.Vaults.MutableResourceVault`1"/> or a customized version of the same
            <seealso cref="T:DotNetVault.CustomVaultExamples.CustomVaults.StringBuilderVault"/>.  Access to the mutable resource is not exposed directly by this lock object but rather
            can be queried by delegates annotated with the <seealso cref="T:DotNetVault.Attributes.NoNonVsCaptureAttribute"/> attribute: this prevents the protected mutable
            resource from being leaked out or prevents unprotected mutable state from becoming a part of the protected resource.
            </summary>
            <typeparam name="TVault">The vault type</typeparam>
            <typeparam name="TResource">The protected resource type</typeparam>
            <seealso cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/>
        </member>
        <member name="M:DotNetVault.LockedResources.LockedVaultMutableResource`2.CreateLockedResource(`0,DotNetVault.Vaults.Vault{`1}.Box)">
            <summary>
            This method creates a mutable resource vault.  It is internal because it should be called only by a <see cref="T:DotNetVault.LockedResources.LockedVaultMutableResource`2"/>
            It is not intended to be used directly by client code.
            </summary>
            <param name="vault">the vault that this locked resource is obtained from</param>
            <param name="box">The vault's box object</param>
            <returns>the locked mutable resource vault.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:DotNetVault.LockedResources.LockedVaultMutableResource`2.ExecuteQuery``2(DotNetVault.LockedResources.VaultQuery{`1,``0,``1},``0@)">
            <summary>
            Execute a query on the mutable resource
            </summary>
            <typeparam name="TAncillary">an ancillary value to be used in the query</typeparam>
            <typeparam name="TResult">the result of the query</typeparam>
            <param name="q">the query delegate</param>
            <param name="val">the ancillary value</param>
            <returns>the result of the delegate execution.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotNetVault.LockedResources.LockedVaultMutableResource`2.ExecuteQuery``1(DotNetVault.LockedResources.VaultQuery{`1,``0})">
            <summary>
            Execute a query on the mutable resource
            </summary>
            <typeparam name="TResult">the result of the query</typeparam>
            <param name="q">the query delegate</param>
            <returns>the result of the delegate execution.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotNetVault.LockedResources.LockedVaultMutableResource`2.ExecuteAction(DotNetVault.LockedResources.VaultAction{`1})">
            <summary>
            Perform a mutation on the protected resource.
            </summary>
            <param name="action">the action</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotNetVault.LockedResources.LockedVaultMutableResource`2.ExecuteAction``1(DotNetVault.LockedResources.VaultAction{`1,``0},``0@)">
            <summary>
            Perform a mutation on the protected resource.
            </summary>
            <typeparam name="TAncillary">an ancillary to be used by the mutation delegate</typeparam>
            <param name="action">the mutation action</param>
            <param name="ancillaryValue">the ancillary value</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotNetVault.LockedResources.LockedVaultMutableResource`2.ExecuteMixedOperation``1(DotNetVault.LockedResources.VaultMixedOperation{`1,``0})">
            <summary>
            Executes a query on the mutable resource, while potentially performing a mutation on it.
            </summary>
            <typeparam name="TResult">The result object</typeparam>
            <param name="mixedOp">The mixed query/mutate delegate</param>
            <returns>the result</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotNetVault.LockedResources.LockedVaultMutableResource`2.ExecuteMixedOperation``2(DotNetVault.LockedResources.VaultMixedOperation{`1,``0,``1},``0@)">
            <summary>
            Executes a query on the mutable resource, while potentially performing a mutation on it.
            </summary>
            <typeparam name="TResult">The result object</typeparam>
            <typeparam name="TAncillary">the ancillary object type that should be used by the delegate</typeparam>
            <param name="mixedOp">The mixed query/mutate delegate</param>
            <param name="ancillary">the ancillary object</param>
            <returns>the result</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotNetVault.LockedResources.LockedVaultMutableResource`2.Dispose">
            <summary>
            Returns the locked resource back to the vault whence it came
            making it available to other threads
            </summary>
        </member>
        <member name="P:DotNetVault.Miscellaneous.ResourceManager`1.Value">
            <summary>
            Get the current value
            </summary>
            <exception cref="T:System.ObjectDisposedException"> object is disposed</exception>
            <exception cref="T:System.InvalidOperationException">value has never been set</exception>
        </member>
        <member name="T:DotNetVault.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:DotNetVault.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:DotNetVault.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:DotNetVault.Resources.AnalyzerDescription">
            <summary>
              Looks up a localized string similar to VaultSafe types should be vault-safe..
            </summary>
        </member>
        <member name="P:DotNetVault.Resources.AnalyzerMessageFormat">
            <summary>
              Looks up a localized string similar to Type name &apos;{0}&apos; is annotated with the VaultSafe attribute but is not provably vault-safe..
            </summary>
        </member>
        <member name="P:DotNetVault.Resources.AnalyzerTitle">
            <summary>
              Looks up a localized string similar to Types annotated with the VaultSafe attribute must be vault-safe..
            </summary>
        </member>
        <member name="M:DotNetVault.UtilitySources.DelegateNoNonVsCaptureAnalyzerSource.DelegateNoNonVsCaptureAnalyzer.ScanForNoNonVsCaptureAttribAndRetrieveAnalyteData(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)">
            <summary>
            Scan the analysis context to 
                1-  determine whether the operation involves the creation of a delegate
                    annotated with the <see cref="T:DotNetVault.Attributes.NoNonVsCaptureAttribute"/> attribute and, if so
                2-  gather the information needed to perform compliance analysis
            </summary>
            <param name="con">the operation analysis context.  for efficiency purposes, it is best to only supply a context
             whose <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.Operation"/> property returns an object of type <see cref="T:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation"/>:
             if not, no further analysis is needed or required.  </param>
            <returns>A value tuple whose first value is true if further analysis is required or false otherwise.  If true, the other
            values in the tuple are guaranteed not to be null.  If false, the other values are undefined and may well be null.</returns>
            <exception cref="T:System.OperationCanceledException"></exception>
        </member>
        <member name="M:DotNetVault.UtilitySources.DelegateNoNonVsCaptureAnalyzerSource.DelegateNoNonVsCaptureAnalyzer.AnalyzeOperationForCompliance(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)">
            <summary>
            Scan the specified delegate creation operation <paramref name="delCrOp"/> to ensure it complies with rules associated with
            delegates annotated with the <seealso cref="T:DotNetVault.Attributes.NoNonVsCaptureAttribute"/> attribute.  All the parameters passed should be retrieval
            results for a call to the <see cref="M:DotNetVault.UtilitySources.DelegateNoNonVsCaptureAnalyzerSource.DelegateNoNonVsCaptureAnalyzer.ScanForNoNonVsCaptureAttribAndRetrieveAnalyteData(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)"/> whose IdentifiedAttribute value is true.
            </summary>
            <param name="targetOp">The target operation as retrieved by the <see cref="M:DotNetVault.UtilitySources.DelegateNoNonVsCaptureAnalyzerSource.DelegateNoNonVsCaptureAnalyzer.ScanForNoNonVsCaptureAttribAndRetrieveAnalyteData(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)"/> method.</param>
            <param name="delCrOp">The delegate creation operation as retrieved by the <see cref="M:DotNetVault.UtilitySources.DelegateNoNonVsCaptureAnalyzerSource.DelegateNoNonVsCaptureAnalyzer.ScanForNoNonVsCaptureAttribAndRetrieveAnalyteData(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)"/> method.</param>
            <param name="assignee">The named type symbol as retrieved by the <see cref="M:DotNetVault.UtilitySources.DelegateNoNonVsCaptureAnalyzerSource.DelegateNoNonVsCaptureAnalyzer.ScanForNoNonVsCaptureAttribAndRetrieveAnalyteData(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)"/> method</param>
            <param name="con">the operation analysis context</param>
            <returns>A value tuple.  The first value will be: true if operation is known to be compliant, false if operation is known to be non-compliant and
            null if its compliance vel-non is unknown.  If false, NonVsCaptures will contain all offending type symbols that are not vault safe and NonVsCapture text
            (the arrays are to be considered parallel) will contain brief text explaining the reason for that symbol's non compliance.</returns>
            <exception cref="T:System.ArgumentNullException">one of the parameters was null.</exception>
            <exception cref="T:System.OperationCanceledException">analysis was cancelled</exception>
        </member>
        <member name="P:DotNetVault.Vaults.Vault`1.DisposeTimeout">
            <summary>
            Amount of time to obtain lock during disposal.  Should be significantly longer than
            </summary>
        </member>
    </members>
</doc>
